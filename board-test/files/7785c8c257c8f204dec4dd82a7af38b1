1. DB 트랜잭션
-DBMS의 성능은 초당 트랜잭션의 실행 수 TPS(Transaction per second)로 측정

(1)성질
-Atomicity(원자성) : 트랜잭션 연산이 모두 반영되든지 모두 반영되지 않든지
현재 수행 트랜잭션에서 오류 발생시 현재 내역을 날리고 임시 저장했던 상태로 rollback한다. 이전 데이터를 임시로 저장되는 영역을 rollback segment라고 하며 
현재 수행 트랜잭션에 의해 새롭게 변경되는 내역을 데이터베이스 테이블이라고 한다. rollback segment에 의해 트랜잭션의 원자성이 보장된다.
rollback시 트랜잭션의 길이가 길어지면 오류가 발생하지 않은 부분도 다시 처음부터 작업하는 것은 비효율적이므로 중간 저장 지점인 save point를 지정할 수 있다.


-Consistency(일관성) : 트랜잭션 실행 성공시 일관성있는 데이터베이스 상태로 변환
일관성은 트랜잭션 수행 전, 후 데이터 모델의 모든 제약조건을 만족하는 것을 보장한다.
trigger를 통해 트랜잭션의 일관성을 보장한다.


-Isolation(독립성,격리성) : 둘 이상의 트랜잭션 동시 병행 실행시 하나의 트랜잭션 실행 중에 다른 연산이 끼어들 수 없고 다른 트랜잭션의 수행 결과를 참조할 수 없다.
*병행처리(concurrent processing) : 트랜잭션에 정해진 시간을 할당해서 작업하다가 부여 시간이 끝나면 다른 트랜잭션을 실행하는 방식으로 트랜잭션 처리하는 것
			이 경우 많은 트랜잭션이 조금씩 처리되는 과정에서 공통 데이터가 조작되어 데이터 혼란이 발생할 수 있다(갱신분실, 오손판독, 반복불가능, 팬텀문제 등)
			OS의 세마포어(semaphore)와 비슷한 개념으로 lock & execute unlock을 통해 고립성을 보장한다. -> 데이터를 읽거나 쓸 때 lock을 통해 다른 트랜잭션이 접근하지 못하도록 고립성을 보장하고 수행을 마치면 unlock.
*트랜잭션에서는 데이터 조회시 shared_lock을 함(read only)
*데이터를 쓸 때는 다른 트랜잭션이 읽고 쓸 수 없도록 하는 exclusive_lock을 사용. -> 작업 종료시 unlock을 통해 다른 트랜잭션이 lock을 할 수 있도록 함. => lock과 unlock을 잘못사용하면 deadlock상태에 빠질 수 있다.(모든 트랜잭션이 아무것도 할 수 없음)
*2PL 프로토콜(2 phase Locking protocol) : 특정 규칙에 의해 고립성을 보장하는 프로토콜. 여러 트랜잭션이 공유하고 있는 데이터에 동시에 접근할 수 없도록 하기 위한 목적을 가진 프로토콜
=> 2가지 locking인 growing phase(상승단계 : read_lock, write_lock)와 shrinking phase(하강 단계 : unlock)가 존재. =>  2PL 프로토콜은 상승 단계와 하강 단계가 섞이면 안되는 것을 의미(lock과 unlock이 번갈아 수행되면 안된다는 것)
*참고 : conservative locking(보수적 locking) : 데드락이 발생하지 않지만 병행성이 좋지 못함
	strict locking(엄격한 locking) : lock을 가지고 있다가 commit을 만날 때 unlock하는 방식으로 데드락이 발생하지만 병행성이 좋음(일반적인 사용 방식)
#결론 : 성능을 위해 병행처리를 해야 하는데 트랜잭션의 고립성을 보장하기 위해 2PL을 사용해야 한다.(Serializable Schedule)




-Durability(영속성) : 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다.



(2)상태
-활동(Active) : 트랜잭션이 실행중인 상태

-실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태 ---rollback---->철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

-부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태 ---commit---> 완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

(3)사용 이유
-DB 서버에 여러 개의 클라이언트가 동시에 엑세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 데이터 부정합을 방지하기 위해
-부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만 처리해야 하는데 너무 비효율적이므로 병렬로 처리할 수 밖에 없는 현실적인 상황으로 인해 부정합을 방지하고자 하는 것
